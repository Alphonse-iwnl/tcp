# tcp
/sendw:滑动窗口的发送窗口

* 这次用双向队列模拟发送窗口队列,之前用数组比较好模拟窗口的打开关闭和收缩,但有两点问题:

> 1.滑动窗口关闭的时候,左边界的左边部分的数组实际上是空出来的,但不太好利用,因为序列号有序递增,突然把新的序列号加在左侧,不太好再用指针表示窗口了
>
> 2.如果不添加在左边的话,内存利用率极低,当待发送队列充满窗口的时候,必须等待最后发送的序列号ACK,再重置数组和窗口边界至数组开头,实在不合理.

双向队列的pop_front push_back都是常数时间复杂度;

* 上层调用者发起发送请求sendrequest 传入一个待发送序列号和一个超时等待,窗口先检测队列是否达到MAX值,如果没有便将序列号加入队列中,如果
队列大小已经达到MAX则调用dequewait方法等待队列出现新的空间(实则等待ack的到达释放序列号),如果等待中超过指定时限便将该序列号加入待重发序列
集合timeouseq中;

* 上层调用者在收到ACK之后传入调用readack传入收到的ACK和通告窗口大小,滑动窗口通过ACK来释放队列中已被正确接受的序列号(默认累积ACK,也就是释放所有小于ACK
的序列号),同时删除这些序列号存储于map的超时检查

* 窗口调用writeseq发起序列号发送,如果最大发送seq>窗口大小则从队列首发送至窗口右边界,反之则从队首发至队尾,该方法同时将序列号和当时的时间戳存入timeoutrecord map容器,构造函数中利用一个线程来遍历容器中的所有元素,如果有超时元素便记录进入timeoutseq容器,并调用readack假装注销这些序列号.

* 这次exists用了二分查找.

* 上层调用者的职责:

监听滑动窗口中的timeoutseq容器,如果该容器有元素,取出元素(待重发序列号),找到对应数据包准备重发//类似epollwait的监听

如果接收到ACK调用readack及时释放空间,让dequewait方法通知窗口可以加入新的序列号.

//也可以传入调用者的实例 来进行回调通知调用者
