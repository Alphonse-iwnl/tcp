# tcp
/sendwindow:模拟滑动窗口的发送窗口

假设:发送序列是充满的(也可以模拟函数标准输出向窗口写入 添加序列号),发送端的报文中包含序列号和数据,接收端发送ACK和通知窗口大小,接收端启用累积ACK.

optr指向提供窗口左边界,nptr指向第一个在提供窗口中准备发送的序列号,iptr指向右边界.

发送窗口接收到ack和窗口大小的时候,iptr计算相应的位移 窗口打开,同时将optr位移至ack-1的位置(pop)并重置nptr的值 另一端关闭.

发送窗口发送数据是默认从nptr的位置发送到iptr的位置(push),此操作窗口大小没有变化.

> //因为窗口序列号是有序且递增的,序列号查找最好用二分法 但这里面没有用= = 因为用的指针指向缓冲区不太好找到数组索引 就暂时没有用了
> 
> //为每个序列号设置超时检查暂时想不到比较好的实现,从普通的计时器看到redis的超时策略,最后解决是给序列号数组维护一个存时间戳的容器,每次Push就利用序列号的值
> 在容器中存入push时的时间戳,并从外界接受一个超时时间rto,开一个分线程来遍历容器与当前时间戳+rto的值比较,如果有元素大于这个值则对应序列号发送超时,每次pop就删除
> 该序列号在容器对应的元素(emmm
>
> 最后感觉没写对也没写完..
>
> 窗口溢出的问题没有解决:当通知窗口大小+右边界大于整个窗口大小的时候 应该等待序列号发送并pop成功,最终达到optr=iptr=buf[max-1]的时候重置前两个指针,这点在代码中没有体现出来.
